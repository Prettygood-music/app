/**
 * Type Generator for prettygood.music
 * 
 * This script connects to the PostgreSQL database and generates TypeScript
 * interfaces based on the database schema. It focuses on the prettygood schema
 * and creates types for tables, views, and stored procedures.
 */

import { Pool } from 'pg';
import * as fs from 'fs';
import * as path from 'path';

// Database connection configuration
const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432', 10),
  database: process.env.DB_NAME || 'prettygood',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'postgres',
};

// Output path for generated types
const OUTPUT_DIR = process.env.OUTPUT_DIR || path.join(__dirname, '../../../common/src/types/db');
const SCHEMA = 'prettygood';

// Map PostgreSQL types to TypeScript types
const pgToTsType = (pgType: string, isNullable: boolean = false): string => {
  const nullableSuffix = isNullable ? ' | null' : '';

  switch (pgType.toLowerCase()) {
    case 'int':
    case 'int2':
    case 'int4':
    case 'int8':
    case 'smallint':
    case 'integer':
    case 'bigint':
    case 'serial':
    case 'bigserial':
    case 'numeric':
    case 'decimal':
    case 'real':
    case 'double precision':
    case 'float':
    case 'float4':
    case 'float8':
      return `number${nullableSuffix}`;
    case 'boolean':
    case 'bool':
      return `boolean${nullableSuffix}`;
    case 'json':
    case 'jsonb':
      return `any${nullableSuffix}`;
    case 'date':
    case 'timestamp':
    case 'timestamptz':
    case 'timestamp with time zone':
    case 'timestamp without time zone':
      return `Date${nullableSuffix}`;
    case 'uuid':
      return `string${nullableSuffix}`;
    case 'text[]':
    case 'varchar[]':
    case 'character varying[]':
      return `string[]${nullableSuffix}`;
    case 'integer[]':
    case 'int[]':
    case 'int4[]':
      return `number[]${nullableSuffix}`;
    default:
      // For any other type, use string as the default
      return `string${nullableSuffix}`;
  }
};

// Generate interface for a table
const generateTableInterface = async (pool: Pool, tableName: string): Promise<string> => {
  // Get column information for the table
  const { rows } = await pool.query(`
    SELECT
      column_name,
      data_type,
      udt_name,
      is_nullable
    FROM
      information_schema.columns
    WHERE
      table_schema = $1
      AND table_name = $2
    ORDER BY
      ordinal_position
  `, [SCHEMA, tableName]);

  if (rows.length === 0) {
    throw new Error(`No columns found for table ${SCHEMA}.${tableName}`);
  }

  // Start building the interface
  let interfaceStr = `export interface ${toCamelCase(tableName, true)} {\n`;

  // Add each column as a property
  for (const row of rows) {
    const columnName = row.column_name;
    const isNullable = row.is_nullable === 'YES';
    const dataType = row.udt_name || row.data_type;
    
    // Add special handling for array types
    let tsType = '';
    if (dataType.startsWith('_')) {
      // PostgreSQL array type (e.g., _text for text[])
      const baseType = dataType.substring(1);
      tsType = pgToTsType(baseType, false) + '[]';
    } else {
      tsType = pgToTsType(dataType, isNullable);
    }

    interfaceStr += `  ${columnName}${isNullable ? '?' : ''}: ${tsType};\n`;
  }

  interfaceStr += '}\n';
  return interfaceStr;
}

// Generate types for all tables in the schema
const generateAllTypes = async () => {
  const pool = new Pool(dbConfig);

  try {
    // Get all tables in the schema
    const { rows: tables } = await pool.query(`
      SELECT table_name
      FROM information_schema.tables
      WHERE table_schema = $1
      AND table_type = 'BASE TABLE'
      ORDER BY table_name
    `, [SCHEMA]);

    // Ensure output directory exists
    if (!fs.existsSync(OUTPUT_DIR)) {
      fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    // Generate index file
    let indexFileContent = `// Auto-generated database type definitions
// DO NOT EDIT: This file is automatically generated

`;

    // Generate a file for each table
    for (const table of tables) {
      const tableName = table.table_name;
      const interfaceName = toCamelCase(tableName, true);
      
      console.log(`Generating type for ${SCHEMA}.${tableName}...`);
      
      const interfaceContent = await generateTableInterface(pool, tableName);
      const fileName = `${tableName}.ts`;
      
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), interfaceContent);
      
      // Add export to index file
      indexFileContent += `export { ${interfaceName} } from './${tableName}';\n`;
    }

    // Write the index file
    fs.writeFileSync(path.join(OUTPUT_DIR, 'index.ts'), indexFileContent);

    console.log(`Generated TypeScript types for ${tables.length} tables in ${SCHEMA} schema`);

  } catch (error) {
    console.error('Error generating types:', error);
    process.exit(1);
  } finally {
    await pool.end();
  }
};

// Helper function to convert snake_case to CamelCase
function toCamelCase(str: string, upperFirst: boolean = false): string {
  const result = str.toLowerCase().replace(/_([a-z])/g, (match, letter) => letter.toUpperCase());
  if (upperFirst) {
    return result.charAt(0).toUpperCase() + result.slice(1);
  }
  return result;
}

// Run the type generator
generateAllTypes().catch(console.error);
